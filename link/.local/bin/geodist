#!/usr/bin/env python3
# SPDX-FileCopyrightText: Steven Ward
# SPDX-License-Identifier: OSL-3.0

# pylint: disable=line-too-long
# pylint: disable=missing-function-docstring
# pylint: disable=missing-module-docstring
# pylint: disable=no-else-return

# All circular angles are in degrees.

import math
import os
import sys

from ellipsoid import geodetic_to_ecef, WGS84


def normalize_angle_deg_signed(a_deg: float) -> float:
	return math.remainder(a_deg, 360)


def normalize_latitude_deg(lat_deg: float) -> float:
	lat_deg = normalize_angle_deg_signed(lat_deg)
	if lat_deg < -90:
		lat_deg = -180 - lat_deg
	elif lat_deg > 90:
		lat_deg = 180 - lat_deg
	return lat_deg


def normalize_longitude_deg(lon_deg: float) -> float:
	lon_deg = normalize_angle_deg_signed(lon_deg)
	return lon_deg


def normalize_geodetic_deg(lat_deg: float, lon_deg: float) -> tuple:
	lat_deg = normalize_angle_deg_signed(lat_deg)

	if lat_deg < -90:
		lat_deg = -180 - lat_deg
		lon_deg += 180
	elif lat_deg > 90:
		lat_deg = 180 - lat_deg
		lon_deg += 180

	lon_deg = normalize_longitude_deg(lon_deg)

	return (lat_deg, lon_deg)


def angle_deg_diff(a1_deg: float, a2_deg: float) -> float:
	return normalize_angle_deg_signed(a2_deg - a1_deg)


# https://en.wikipedia.org/wiki/Haversine_formula
# http://www.movable-type.co.uk/scripts/latlong.html
def haversine_deg_dist(lat1_deg: float, lon1_deg: float, lat2_deg: float, lon2_deg: float) -> float:
	# pylint: disable=redefined-outer-name
	'''Get the haversine distance between 2 geodetic coordinates.'''

	sin_lat1 = math.sin(math.radians(lat1_deg))
	cos_lat1 = math.cos(math.radians(lat1_deg))

	sin_lat2 = math.sin(math.radians(lat2_deg))
	cos_lat2 = math.cos(math.radians(lat2_deg))

	R1 = WGS84.get_R(sin_lat1)
	R2 = WGS84.get_R(sin_lat2)
	R = (R1+R2)/2

	lat_diff_rad = math.radians(angle_deg_diff(lat1_deg, lat2_deg))
	lon_diff_rad = math.radians(angle_deg_diff(lon1_deg, lon2_deg))

	# a is the square of half the chord length between the points
	a = math.sin(lat_diff_rad/2)**2 + cos_lat1 * cos_lat2 * math.sin(lon_diff_rad/2)**2

	# c is the angular distance in radians
	c = 2 * math.asin(math.sqrt(a))

	return R * c


def euclidian_deg_dist(lat1_deg: float, lon1_deg: float, lat2_deg: float, lon2_deg: float) -> float:
	# pylint: disable=redefined-outer-name
	'''Get the Euclidian distance between 2 geodetic coordinates.'''
	(x1, y1, z1) = geodetic_to_ecef(WGS84, lat1_deg, lon1_deg, 0)
	(x2, y2, z2) = geodetic_to_ecef(WGS84, lat2_deg, lon2_deg, 0)
	return math.dist((x1, y1, z1), (x2, y2, z2))


for line in sys.stdin:
	(lat1_deg, lon1_deg, lat2_deg, lon2_deg) = map(float, line.strip(os.linesep).split())
	(lat1_deg, lon1_deg) = normalize_geodetic_deg(lat1_deg, lon1_deg)
	(lat2_deg, lon2_deg) = normalize_geodetic_deg(lat2_deg, lon2_deg)

	result_haversine = haversine_deg_dist(lat1_deg, lon1_deg, lat2_deg, lon2_deg)
	result_euclid = euclidian_deg_dist(lat1_deg, lon1_deg, lat2_deg, lon2_deg)

	print(f'{result_haversine=}')
	print(f'{result_euclid=}')

